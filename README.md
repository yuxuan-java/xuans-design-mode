# xuans-design-mode 设计模式

## 不要用面向对象的语言，却写着面向过程的code

- 面向对象设计模式体现的就是抽象的思想，类是对对象的抽象，抽象类是对类的抽象，接口是对行为的抽象。
- 信息的隐藏促进了软件的复用。
- 如果两个类之间不必彼此直接通信，那么就不要让这两个类发生直接的相互作用。
- 代码重复是编程中最常见、最糟糕的'坏味道'，如果我们在一个以上的地方看到相同的程序结构，那么请设法将它们合二为一。
- 完全相同的代码当然存在明显的重复，而微妙的重复会出现在表面不同但是本质相同的结构或处理步骤中。

## 设计模式的七大原则

### 1、单一职责原则（Single Responsibility Principle）
    就一个类而言，应该仅有一个引起它变化的原因。
    如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其它职责的能力。
    这种耦合会导致脆弱的设计，当变化发生时，设计会遭受意想不到的破坏。
    如果你能想到多于一个的动机去改变一个类，那么这个类就具有对于一个的职责。
    软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。
### 2、开闭原则（Open Close Principle）
    开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。
    所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。
    想要达到这样的效果，我们需要使用接口和抽象类。
### 3、里氏代换原则（Liskov Substitution Principle）
    里氏代换原则是面向对象设计的基本原则之一。 
    里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 
    LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。
    里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。
    而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
### 4、依赖倒转原则（Dependence Inversion Principle）
    这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。
### 5、接口隔离原则（Interface Segregation Principle）
    这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。
    还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。
    目的还是降低依赖，降低耦合。
### 6、迪米特法则（最少知道原则 - Demeter Principle）
    最少知道原则就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
### 7、合成复用原则（Composite Reuse Principle）
    原则是尽量使用合成/聚合的方式，而不是使用继承。

## 一.创建型模式

- 创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。
  这样，创建型模式在创建什么、谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性。
  创建型模式会将关于该系统使用哪些具体的类的信息封装起来。
  允许用结构和功能差别很大的对象配置一个系统。
  配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时再指定。
  当一个系统应该独立于它们的产品创建、构成和表示时，应该考虑创建型模式。

- 内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度。
    而耦合性描述的是一个例程与其他例程之间联系的紧密程度。
    软件开发的目标应该是创建这样的例程：
        内部完整，也就是高内聚
        与其他例程之间的联系则是小巧、直接、可见、灵活的，这就是松耦合
    
### 1. 简单工厂模式：
    让业务逻辑与客户端逻辑分开，让它们之间耦合度下降。
    简单工厂模式并不符合开放-封闭原则
        
### 2. 抽象工厂模式：
    提供一个创建一系列或相关依赖对象的接口，而无需指定它们具体的类。
        
### 3. 建造者模式：
    将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
    
### 4. 工厂方法模式：
    定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法模式使一个类的实例化延迟到其子类。
    通常设计应该是从工厂方法模式开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。
    当设计者在设计标准之间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地。

### 5. 原型模式：
    用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
    建立相应数据的原型并克隆它们，通常比每次用合适的状态手工实例化该类更方便一些。

### 6. 单例模式：
    保证一个类仅有一个实例，并提供一个访问它的全局访问点。
    让类自身负责保存它的唯一实例。
    这个类可以保证没有其他实例可以被创建，并且还提供一个访问该实例的方法。
    对唯一的实例可以严格地控制客户怎样以及何时访问它。

## 二.结构型模式
    
### 1.适配器模式：
    将一个类的接口转换成客户希望的另外一个接口。
    适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起协同工作。
    主要是为了解决两个已有接口之间不匹配的问题，不需要考虑这些接口是怎样实现的，也不需要考虑它们各自可能会如何演化。
    适配器模式不需要对两个独立设计的类中任一个进行重新设计，就能够使它们协同工作。
        
### 2.桥接模式：
    将抽象部分与它的实现部分分离，使它们都可以独立地变化。
    解耦这些不同方向的变化，通过对象组合的方式，把两个角色之间的继承关系改为了组合的关系，从而使这两者可以应对各自独立的变化。
        
### 3.组合模式：
    将对象组合成树形结构以表示'部分-整体'的层次结构，组合模式使得用户对象单个和组合对象的使用具有一致性。
    客户端可以一致地使用组合结构和单个对象，任何用到基本对象的地方都可以使用组合对象。
        
### 4.装饰模式：
    动态、透明地给一个对象添加一些额外的职责。
    就增加功能来说，装饰模式比生成子类更加灵活。
    
### 5.外观模式：
    为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
    想让一个软件中的子系统间的通信和相互依赖关系达到最小，办法就是引入一个外观对象，它为子系统间提供了一个单一而简单的屏障。
        
### 6.享元模式：
    为运用共享技术有效地支持大量细粒度的对象。
    面向对象技术有时会因简单化的设计而代价极大。
    对象使得内存占用过多，而且如果都是大量重复的对象，那就是资源的极大浪费。
    
### 7.代理模式：
    为其他对象提供一种代理以控制这个对象的访问。
        
### 对比：
    代理模式与外观模式的主要区别：
        代理对象表示一个单一对象而外观对象代表一个子系统；
        代理的客户对象无法直接访问目标对象，由代理提供对单独的目标对象的访问控制，
        而外观的客户对象可以直接访问子系统中的各个对象，但通常由外观对象提供对子系统各元件功能的简化的共同层次的调用接口。
        
    代理模式与适配器模式：
        代理是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个代表交涉。
        而适配器则不需要虚构出一个代表者，只需要为应付特定使用目的，将原来的类进行一些组合。
    
事实上，在现实中，早已设计好的两个类，过后需要它们统一接口，整合为一的实例也比比皆是。
因此桥接模式和适配器模式是被用于软件生命周期的不同阶段，针对的是不同的问题，谈不上孰优孰劣。

外观模式和适配器模式有些近似，都是对现存系统的封装。
外观模式定义的是一个新的接口，而适配器模式则是复用一个原有的接口，
适配器是使两个已有的接口协同工作，而外观模式则是为现存系统提供一个更为方便的访问接口。
适配器模式使用来适配对象的，而外观模式是用来适配整个子系统的，外观模式所针对的对象粒度更大一些。

## 三.行为型模式

### 1. 观察者模式：
    定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
    
### 2. 模板方法模式：
    定义一个操作的算法骨架，而将一些步骤延迟到子类中，模板方法模式使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。
    模板方法模式由一个抽象类组成，这个抽象类定义了需要覆盖的可能有不同实现的模板方法，每个从这个抽象类派生的具体类将为此模板实现新方法。
    
### 3. 命令模式：
    将一个请求封装为一个对象，从而使你可用不同的请求对客户端进行参数化；
    可以对请求排队或记录请求日志，以及支持可撤销的操作。
    将调用操作的对象与指导如何实现该操作的对象解耦，在不同的时刻指定、排列和执行请求。
    支持取消/重做的操作、记录整个操作的日志、支持事务。
    利用命令模式分离请求者与实现者，是最明智的选择。
    
### 4. 状态模式：
    允许一个对象在其内部状态改变时改变它的行为，让对象看起来似乎改变了它的类。
    状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定状态转移的逻辑不在单块的if或switch中，
    而是分布在各个状态子类之间，由于所有与状态相关的代码都存在于某个状态子类中，
    所以通过定义新的子类就可以很容易地增加新的状态和转换。
    把分支语句进行分解并封装成多个子类，利用多态来提高其可维护、可扩展的需要。
    
### 5. 责任链模式：
    使多个对象都有机会处理请求，从而避免请求的发送者和接收者(具体处理者)之间的耦合关系。
    将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
    当有多个对象可以处理一个请求，哪个对象处理该请求事先并不知道，要在运行时刻自动确定时，
    让客户在不明确指定接收者的情况下，提交一个请求，然后由所有能处理这请求的对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

### 6. 解释器模式：
    给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
    如果一种特定类型的问题发生的频率足够高，那么久可以考虑将该问题的各个实例表示为一个简单语言中的句子。
    也就是说，通过构建一个解释器，该解释器解释这些句子来解决该问题。
    
### 7. 中介者模式：
    用一个中介对象来封装一系列的对象交互。
    中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地高边它们之间的交互。
    面向对象设计鼓励将行为分布到各个对象中，这种分部可能会导致对象间有许多连接。
    也就是说，有可能每一个对象都需要知道其他许多对象。对象间的大量相互连接使得一个对象似乎不太可能在没有其他对象的支持下工作，
    这对于应对变化时不利的，任何较大的对象不再相互显式引用。这些对象仅知道中介者，从而减少了相互连接的数目。
    最少知识原则，也就是如何减少耦合问题，类之间的耦合越弱，越也有利于复用。

### 8. 访问者模式：
    表示一个作用于某对象结构中的各元素的操作。
    它使你可以在不改变任何元素的前提下定义作用于这些元素的新操作。
    访问者增加具体的Element是困难的，但增加依赖于复杂对象结构的构件的操作就变得容易。
    仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。

### 9. 策略模式：
    定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。
    策略模式使得算法可独立于使用它们的客户端而变化。
    继承提供了一种支持多种算法或行为的方法，我们可以直接生成一个类A的子类B、C、D，从而给它以不同的行为。
    但这样会将行为硬性编制到父类A当中，而将算法的实现与类A的实现混合起来，从而使得类A难以理解、难以维护和难以扩展，而且还不能动态地改变算法。
    仔细分析会发现，它们之间唯一差别是它们所使用的算法或行为，将算法封装在独立的策略Strategy类中使得你可以独立于其类A改变它，
    使它易于切换、易于理解、易于扩展。

### 10. 备忘录模式：
    在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。
    使用备忘录模式可以避免暴露一些只应由对象A管理却又必须存储在对象A之外的信息。
    备忘录模式把可能很复杂的对象A的内部信息对其他对象屏蔽起来，从而保持了封装边界。
    
### 11. 迭代器模式：
    提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象的内部表示。
    迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器对象中，迭代器类定义了一个访问该列表元素的接口。
    迭代器对象负责跟踪当前的元素，并且知道哪些元素已经遍历过了。

祝愿你在阅读本书的过程当中，读有所获，阅有所思。
书籍一定会有最后一页，但你的面向对象编程之路或许才刚刚开始。
相信通过你的努力，你的人生会更加精彩。《大话设计模式》




































